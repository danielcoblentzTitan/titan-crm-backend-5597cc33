import { supabase } from "@/integrations/supabase/client";
import { Lead } from "./supabaseService";

export interface Estimate {
  id: string;
  lead_id: string;
  lead_name: string;
  building_type: string;
  dimensions?: string;
  wall_height?: string;
  estimated_price: number;
  description?: string;
  scope?: string;
  timeline?: string;
  notes?: string;
  detailed_breakdown?: any;
  status: string;
  is_written_estimate: boolean;
  is_auto_generated?: boolean;
  created_at: string;
  updated_at: string;
  created_by?: string;
  version_name?: string;
}

export interface EstimateFormData {
  buildingType: string;
  dimensions: string;
  wallHeight: string;
  estimatedPrice: number;
  description: string;
  scope: string;
  timeline: string;
  notes: string;
  detailedBreakdown?: any;
}

class EstimatesService {
  async getEstimates(): Promise<Estimate[]> {
    const { data, error } = await supabase
      .from('estimates')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching estimates:', error);
      throw error;
    }

    return data || [];
  }

  async getEstimateById(id: string): Promise<Estimate | null> {
    const { data, error } = await supabase
      .from('estimates')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      console.error('Error fetching estimate:', error);
      return null;
    }

    return data;
  }

  async getEstimatesByLead(leadId: string): Promise<Estimate[]> {
    console.log('EstimatesService: Getting estimates for lead:', leadId);
    const { data, error } = await supabase
      .from('estimates')
      .select('*')
      .eq('lead_id', leadId)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching estimates for lead:', error);
      throw error;
    }

    console.log('EstimatesService: Raw data from database:', data);
    if (data && data.length > 0) {
      console.log('EstimatesService: First estimate price:', data[0].estimated_price, 'Type:', typeof data[0].estimated_price);
    }

    return data || [];
  }

  async createEstimate(lead: Lead, estimateData: EstimateFormData, isAutoGenerated: boolean = false): Promise<Estimate> {
    // Get the next version number for this lead
    const { data: existingEstimates } = await supabase
      .from('estimates')
      .select('id')
      .eq('lead_id', lead.id);
    
    const nextVersionNumber = (existingEstimates?.length || 0) + 1;
    const versionName = `Version ${nextVersionNumber}`;

    const { data, error } = await supabase
      .from('estimates')
      .insert({
        lead_id: lead.id,
        lead_name: `${lead.first_name} ${lead.last_name}`,
        building_type: estimateData.buildingType,
        dimensions: estimateData.dimensions,
        wall_height: estimateData.wallHeight,
        estimated_price: estimateData.estimatedPrice,
        description: estimateData.description,
        scope: estimateData.scope,
        timeline: estimateData.timeline,
        notes: estimateData.notes,
        detailed_breakdown: estimateData.detailedBreakdown,
        version_name: versionName,
        status: 'Draft',
        is_auto_generated: isAutoGenerated
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating estimate:', error);
      throw error;
    }

    return data;
  }

  async createEstimateFromData(estimateData: any): Promise<Estimate> {
    // Get the next version number for this lead if version_name is not provided
    let versionName = estimateData.version_name;
    if (!versionName) {
      const { data: existingEstimates } = await supabase
        .from('estimates')
        .select('id')
        .eq('lead_id', estimateData.lead_id);
      
      const nextVersionNumber = (existingEstimates?.length || 0) + 1;
      versionName = `Version ${nextVersionNumber}`;
    }

    const { data, error } = await supabase
      .from('estimates')
      .insert({
        lead_id: estimateData.lead_id,
        lead_name: estimateData.lead_name,
        building_type: estimateData.building_type,
        dimensions: estimateData.dimensions,
        wall_height: estimateData.wall_height,
        estimated_price: estimateData.estimated_price,
        description: estimateData.description,
        scope: estimateData.scope,
        timeline: estimateData.timeline,
        notes: estimateData.notes,
        version_name: versionName,
        status: 'Draft'
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating estimate from data:', error);
      throw error;
    }

    return data;
  }

  async updateEstimate(id: string, estimateData: any): Promise<Estimate> {
    const updateData: any = {};
    
    // Handle both old (camelCase) and new (snake_case) formats
    if (estimateData.buildingType !== undefined) updateData.building_type = estimateData.buildingType;
    if (estimateData.building_type !== undefined) updateData.building_type = estimateData.building_type;
    if (estimateData.dimensions !== undefined) updateData.dimensions = estimateData.dimensions;
    if (estimateData.wallHeight !== undefined) updateData.wall_height = estimateData.wallHeight;
    if (estimateData.wall_height !== undefined) updateData.wall_height = estimateData.wall_height;
    if (estimateData.estimatedPrice !== undefined) updateData.estimated_price = estimateData.estimatedPrice;
    if (estimateData.estimated_price !== undefined) updateData.estimated_price = estimateData.estimated_price;
    if (estimateData.description !== undefined) updateData.description = estimateData.description;
    if (estimateData.scope !== undefined) updateData.scope = estimateData.scope;
    if (estimateData.timeline !== undefined) updateData.timeline = estimateData.timeline;
    if (estimateData.notes !== undefined) updateData.notes = estimateData.notes;
    if (estimateData.detailedBreakdown !== undefined) updateData.detailed_breakdown = estimateData.detailedBreakdown;
    if (estimateData.version_name !== undefined) updateData.version_name = estimateData.version_name;

    const { data, error } = await supabase
      .from('estimates')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('Error updating estimate:', error);
      throw error;
    }

    return data;
  }

  async convertToWrittenEstimate(id: string): Promise<Estimate> {
    const { data, error } = await supabase
      .from('estimates')
      .update({ 
        is_written_estimate: true,
        status: 'Written Estimate'
      })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('Error converting to written estimate:', error);
      throw error;
    }

    return data;
  }

  async convertToQuickWrittenEstimate(id: string): Promise<Estimate> {
    const { data, error } = await supabase
      .from('estimates')
      .update({ 
        is_written_estimate: true,
        status: 'Quick Estimate'
      })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('Error converting to quick written estimate:', error);
      throw error;
    }

    return data;
  }

  async deleteEstimate(id: string): Promise<void> {
    const { error } = await supabase
      .from('estimates')
      .delete()
      .eq('id', id);

    if (error) {
      console.error('Error deleting estimate:', error);
      throw error;
    }
  }

  async updateEstimateStatus(id: string, status: string): Promise<Estimate> {
    const { data, error } = await supabase
      .from('estimates')
      .update({ status })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('Error updating estimate status:', error);
      throw error;
    }

    return data;
  }
}

export const estimatesService = new EstimatesService();